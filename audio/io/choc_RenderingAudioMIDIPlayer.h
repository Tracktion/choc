//
//    ██████ ██   ██  ██████   ██████
//   ██      ██   ██ ██    ██ ██            ** Classy Header-Only Classes **
//   ██      ███████ ██    ██ ██
//   ██      ██   ██ ██    ██ ██           https://github.com/Tracktion/choc
//    ██████ ██   ██  ██████   ██████
//
//   CHOC is (C)2022 Tracktion Corporation, and is offered under the terms of the ISC license:
//
//   Permission to use, copy, modify, and/or distribute this software for any purpose with or
//   without fee is hereby granted, provided that the above copyright notice and this permission
//   notice appear in all copies. THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
//   WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
//   AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
//   CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
//   WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
//   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#ifndef CHOC_RENDERINGAUDIOMIDIPLAYER_HEADER_INCLUDED
#define CHOC_RENDERINGAUDIOMIDIPLAYER_HEADER_INCLUDED

#include <thread>
#include "choc_AudioMIDIPlayer.h"

namespace choc::audio::io
{

//==============================================================================
/**
 *  An AudioMIDIPlayer implementation that runs a fake audio device on a thread,
 *  reading/writing its data via functions supplied by the caller.
 */
struct RenderingAudioMIDIPlayer  : public AudioMIDIPlayer
{
    /// You provide this function to generate blocks of input for the player.
    /// The background thread of RenderingAudioMIDIPlayer will repeatedly call
    /// this. It should return true if it wants to carry on, or false to cause
    /// the player to stop.
    using ProvideInputFn = std::function<bool(choc::buffer::ChannelArrayView<float> audioInput,
                                              std::vector<choc::midi::ShortMessage>& midiMessages,
                                              std::vector<uint32_t>& midiMessageTimes)>;

    /// You provide this function to handle the blocks of output generated by the player.
    /// The background thread of RenderingAudioMIDIPlayer will repeatedly call
    /// this. It should return true if it wants to carry on, or false to cause
    /// the player to stop.
    using HandleOutputFn = std::function<bool(choc::buffer::ChannelArrayView<const float>)>;

    RenderingAudioMIDIPlayer (const AudioDeviceOptions&, ProvideInputFn, HandleOutputFn);
    ~RenderingAudioMIDIPlayer() override;

    std::string getLastError() override                                 { return {}; }
    std::vector<uint32_t> getAvailableSampleRates() override            { return {}; }
    std::vector<uint32_t> getAvailableBlockSizes() override             { return {}; }
    std::vector<std::string> getAvailableAudioAPIs() override           { return {}; }
    std::vector<AudioDeviceInfo> getAvailableInputDevices() override    { return {}; }
    std::vector<AudioDeviceInfo> getAvailableOutputDevices() override   { return {}; }
    std::vector<std::string> getAvailableMIDIInputDevices() override    { return {}; }
    std::vector<std::string> getAvailableMIDIOutputDevices() override   { return {}; }

private:
    ProvideInputFn provideInput;
    HandleOutputFn handleOutput;
    std::thread renderThread;

    void start() override;
    void stop() override;
    void handleOutgoingMidiMessage (const void*, uint32_t) override {}
    void render();
};




//==============================================================================
//        _        _           _  _
//     __| |  ___ | |_   __ _ (_)| | ___
//    / _` | / _ \| __| / _` || || |/ __|
//   | (_| ||  __/| |_ | (_| || || |\__ \ _  _  _
//    \__,_| \___| \__| \__,_||_||_||___/(_)(_)(_)
//
//   Code beyond this point is implementation detail...
//
//==============================================================================

inline RenderingAudioMIDIPlayer::RenderingAudioMIDIPlayer (const AudioDeviceOptions& o, ProvideInputFn in, HandleOutputFn out)
    : AudioMIDIPlayer (o), provideInput (std::move (in)), handleOutput (std::move (out))
{
    // Because there are no restrictions on these values, they need to
    // be specified by the caller
    CHOC_ASSERT (options.blockSize != 0);
    CHOC_ASSERT (options.sampleRate != 0);
}

inline RenderingAudioMIDIPlayer::~RenderingAudioMIDIPlayer()
{
    stop();
}

inline void RenderingAudioMIDIPlayer::start()
{
    renderThread = std::thread ([this] { render(); });
}

inline void RenderingAudioMIDIPlayer::stop()
{
    if (renderThread.joinable())
        renderThread.join();
}

inline void RenderingAudioMIDIPlayer::render()
{
    choc::buffer::ChannelArrayBuffer<float> audioInput  (options.inputChannelCount,  options.blockSize);
    choc::buffer::ChannelArrayBuffer<float> audioOutput (options.outputChannelCount, options.blockSize);
    std::vector<choc::midi::ShortMessage> midiMessages;
    std::vector<uint32_t> midiMessageTimes;
    midiMessages.reserve (512);
    midiMessageTimes.reserve (512);

    for (;;)
    {
        midiMessages.clear();
        midiMessageTimes.clear();

        {
            const std::scoped_lock lock (callbackLock);

            if (callbacks.empty())
                return;
        }

        if (! provideInput (audioInput, midiMessages, midiMessageTimes))
            return;

        CHOC_ASSERT (midiMessages.size() == midiMessageTimes.size());

        if (auto totalNumMIDIMessages = static_cast<uint32_t> (midiMessages.size()))
        {
            auto frameRange = audioOutput.getFrameRange();
            uint32_t midiStart = 0;

            while (frameRange.start < frameRange.end)
            {
                auto chunkToDo = frameRange;
                auto endOfMIDI = midiStart;

                while (endOfMIDI < totalNumMIDIMessages)
                {
                    auto eventTime = midiMessageTimes[endOfMIDI];

                    if (eventTime > chunkToDo.start)
                    {
                        chunkToDo.end = eventTime;
                        break;
                    }

                    ++endOfMIDI;
                }

                for (uint32_t i = midiStart; i < endOfMIDI; ++i)
                    addMIDIEvent ({}, midiMessages[i].data(), midiMessages[i].size());

                process (audioInput.getFrameRange (chunkToDo),
                         audioOutput.getFrameRange (chunkToDo),
                         true);

                frameRange.start = chunkToDo.end;
                midiStart = endOfMIDI;
            }
        }
        else
        {
            process (audioInput, audioOutput, true);
        }

        if (! handleOutput (audioOutput))
            return;
    }
}

} // namespace choc::audio::io

#endif // CHOC_RENDERINGAUDIOMIDIPLAYER_HEADER_INCLUDED
